set_loadaddrs=
    setexpr boot_size_bytes ${boot_size} * 0x200 /* block size */;
    setexpr vendor_boot_size_bytes ${vendor_boot_size} * 0x200 /* block size */;
    setexpr vloadaddr ${loadaddr} + ${boot_size_bytes};
    setexpr ramdisk_addr_r ${vloadaddr} + ${vendor_boot_size_bytes};

bootcmd_bootimg=
    /* Pass u-boot version to android */
    setexpr ver_simple gsub "U-Boot (.*) \\\\\\\\(.*\\\\\\\\)" "\\\\\\\\1" "${ver}";
    setenv bootargs "androidboot.bootloader=${ver_simple}";
    /* Set current bootmode */
    if test -z "${android_bootmode}"; then
        setenv android_bootmode "normal";
    fi;
    /* Pass bootmode in cmdline */
    setenv bootargs "androidboot.mode=${android_bootmode} ${bootargs}";
    if test "${android_bootmode}" != "recovery"; then
        /* Boot to system instead of recovery */
        setenv bootargs "androidboot.force_normal_boot=1 ${bootargs}";
    fi;
    /* Determine current slot if not already done */
    if test -z "${slot_name}"; then
        ab_select slot_name mmc 0#misc --no-dec || run fastbootcmd;
    fi;
    /* Pass slot suffix in cmdline */
    setenv bootargs "androidboot.slot_suffix=_${slot_name} ${bootargs}";
    /* Pass serial number in cmdline */
    setenv bootargs "androidboot.serialno=${serial#} ${bootargs}";
    /* Set AVB unlocked to allow using fastbootd */
    setenv bootargs "androidboot.verifiedbootstate=orange ${bootargs}";
    /* Load vendor_boot */
    part start mmc 0 vendor_boot_${slot_name} vendor_boot_start;
    part size mmc 0 vendor_boot_${slot_name} vendor_boot_size;
    /* Set vloadaddr and ramdisk_addr_r */
    run set_loadaddrs;
    mmc read ${vloadaddr} ${vendor_boot_start} ${vendor_boot_size};
    abootimg addr ${loadaddr} ${vloadaddr};
    /* Set up dtb */
    abootimg get dtb --index=0 dtb_addr_r;
    fdt addr ${dtb_addr_r};
    fdt boardsetup;
    part start mmc 0 dtbo_${slot_name} dtbo_start;
    part size mmc 0 dtbo_${slot_name} dtbo_size;
    mmc read ${fdt_addr_r} ${dtbo_start} ${dtbo_size};
    adtimg addr ${fdt_addr_r};
    setenv dtbo_index "0";
    while test -n "${dtbo_index}"; do
        adtimg get dt --index=${dtbo_index} dtbo0_addr dtbo0_size || setenv dtbo_index "";
        if test -n "${dtbo_index}"; then
            fdt resize $dtbo0_size;
            fdt apply $dtbo0_addr;
            setexpr dtbo_index ${dtbo_index} + 1;
        fi;
    done;
    /* Boot Android */
    bootm ${loadaddr} ${loadaddr} ${dtb_addr_r};

bootcmd_android=
    if test "${android_bootmode}" != "recovery"; then
        /* Determine current slot and decrement boot tries */
        ab_select slot_name mmc 0#misc || run fastbootcmd;
    else
        /* Determine current slot */
        ab_select slot_name mmc 0#misc --no-dec || run fastbootcmd;
    fi;
    /* Read boot image to RAM (into $loadaddr) */
    part start mmc 0 boot_${slot_name} boot_start;
    part size mmc 0 boot_${slot_name} boot_size;
    mmc read ${loadaddr} ${boot_start} ${boot_size};

    run bootcmd_bootimg;

bootcmd_android_recovery=
    /* Boot to recovery */
    setenv android_bootmode "recovery";
    run bootcmd_android;

fastbootcmd=
    cls;
    echo "FASTBOOT MODE";
    fastboot usb 0;
    bootmenu;

fastboot_bootcmd=
    run bootcmd_bootimg;

bootmenu_0=
    Boot normally=run bootcmd
bootmenu_1=
    Boot System=run bootcmd_android
bootmenu_2=
    Boot Recovery=run bootcmd_android_recovery
bootmenu_3=
    Enter Fastboot=run fastbootcmd

bootcmd=
    if bcb load 0 misc; then
        /* Valid BCB found */
        if bcb test command = bootonce-bootloader; then
            bcb clear command; bcb store;
            run fastbootcmd;
        elif bcb test command = boot-recovery; then
            bcb clear command; bcb store;
            run bootcmd_android_recovery;
        else
            run bootcmd_android;
        fi;
    else
        /* Non-existent/corrupted BCB, assume normal boot */
        run bootcmd_android;
    fi;
